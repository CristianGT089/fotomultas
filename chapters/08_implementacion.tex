\section{Implementación del prototipo}

La implementación del prototipo se llevó a cabo siguiendo la arquitectura híbrida \textit{blockchain} diseñada en la sección Diseño del prototipo, integrando \textit{Hyperledger Fabric} para la gestión privada de datos sensibles, \textit{Ethereum} para la transparencia pública e \textit{IPFS} dual para el almacenamiento distribuido de evidencias.

\subsection{Entorno de desarrollo y herramientas}

El desarrollo del prototipo se realizó en un entorno Unix (Linux) utilizando las siguientes herramientas:

\begin{itemize}
    \item \textbf{Sistema Operativo:} Ubuntu 22.04 LTS
    \item \textbf{Control de Versiones:} Git 2.34+ para gestión de código fuente
    \item \textbf{Entorno de Ejecución:} \textit{Node.js} v20.18.0 con npm v10.0.0
    \item \textbf{Gestión de Dependencias:} npm para paquetes \textit{JavaScript}/\textit{TypeScript}
    \item \textbf{IDE:} \textit{Visual Studio Code} con extensiones para \textit{Solidity}, \textit{Go} y \textit{TypeScript}
\end{itemize}

\subsection{Stack tecnológico implementado}

\subsubsection{Tecnologías backend}

El backend del sistema se implementó utilizando tecnologías modernas de JavaScript/TypeScript:

\begin{itemize}
    \item \textbf{Framework Web:} \textit{Express.js} v4.18.2 - Framework minimalista para \textit{Node.js}
    \item \textbf{Lenguaje:} \textit{TypeScript} v5.8.3 - Superset tipado de \textit{JavaScript}
    \item \textbf{Validación:} Express-validator v7.2.1 y Joi v17.13.3 - Validación de datos de entrada
    \item \textbf{Documentación API:} Swagger-jsdoc v6.2.8 y Swagger-ui-express v5.0.1
    \item \textbf{Manejo de Archivos:} Multer v1.4.5-lts.2 - Procesamiento de uploads multipart
    \item \textbf{Cliente HTTP:} Axios v1.9.0 - Comunicación con APIs externas
\end{itemize}

\subsubsection{Tecnologías blockchain}

\paragraph{Capa pública - Ethereum}
Para la implementación de la capa pública (justificada en la sección Metodología), se utilizó el ecosistema de Ethereum con las siguientes tecnologías:

\begin{itemize}
    \item \textbf{Framework de Desarrollo:} \textit{Hardhat} v2.24.0 - Entorno de desarrollo \textit{Ethereum}
    \item \textbf{Biblioteca de Interacción:} \textit{Ethers.js} v6.14.0 - Cliente para interactuar con \textit{Ethereum}
    \item \textbf{Lenguaje de Contratos:} \textit{Solidity} v0.8.28 - Lenguaje para \textit{Smart Contracts}
    \item \textbf{Contratos Base:} \textit{OpenZeppelin Contracts} v5.3.0 - Librería de contratos seguros y auditados
    \item \textbf{Generación de Tipos:} \textit{TypeChain} v8.3.2 - Generación automática de tipos \textit{TypeScript} desde \textit{ABI}
\end{itemize}

\paragraph{Capa privada - Hyperledger Fabric}
Para la implementación de la capa privada (justificada en la sección Metodología), se utilizó \textit{Hyperledger Fabric} con las siguientes tecnologías:

\begin{itemize}
    \item \textbf{Plataforma:} \textit{Hyperledger Fabric} v2.5 - Blockchain permisionada empresarial
    \item \textbf{Lenguaje Chaincode:} \textit{Go} v1.21+ - Lenguaje para desarrollo de \textit{chaincode}
    \item \textbf{SDK:} \textit{Fabric SDK} para \textit{Node.js} - Interacción desde el backend
    \item \textbf{Consenso:} \textit{Raft} - Algoritmo de consenso para tolerancia a fallas
    \item \textbf{Gestión de Identidades:} \textit{Fabric CA} - \textit{Certificate Authority} para control de acceso
\end{itemize}

\subsubsection{Almacenamiento de evidencias}

La implementación de IPFS se realizó en dos capas diferenciadas:

\begin{itemize}
    \item \textbf{Implementación:} \textit{Kubo} v0.34.1 - Implementación de referencia de \textit{IPFS}
    \item \textbf{Cliente \textit{JavaScript}:} \textit{ipfs-http-client} v60.0.1 - \textit{API HTTP} para \textit{IPFS}
    \item \textbf{\textit{IPFS} Privado:} Nodo local para almacenamiento de evidencias completas
    \item \textbf{\textit{IPFS} Público:} Gateway público para \textit{hashes} de verificación ciudadana
    \item \textbf{Protocolo de Contenido:} \textit{Multiformats} v13.3.3 - Manejo de \textit{CIDs}
\end{itemize}

\subsubsection{Tecnologías frontend}

El frontend se desarrolló con tecnologías modernas de React:

\begin{itemize}
    \item \textbf{Framework:} \textit{React} v18.3.1 - Biblioteca para interfaces de usuario
    \item \textbf{Bundler:} \textit{Vite} v5.4.2 - Herramienta de build ultrarrápida
    \item \textbf{Lenguaje:} \textit{TypeScript} v5.5.3 - Tipado estático
    \item \textbf{Estilos:} \textit{Tailwind CSS} v3.4.1 - Framework de utilidades \textit{CSS}
    \item \textbf{Enrutamiento:} \textit{React Router DOM} v6.22.3 - Navegación entre vistas
    \item \textbf{Estado Global:} \textit{Zustand} v4.5.2 - Gestión de estado ligera
    \item \textbf{Gráficos:} \textit{Recharts} v2.12.3 - Librería de visualización de datos
    \item \textbf{Iconos:} \textit{Lucide React} v0.344.0 - Iconos modulares
\end{itemize}

\subsubsection{Frameworks de testing}

Se implementaron pruebas automatizadas en múltiples capas:

\begin{itemize}
    \item \textbf{Backend:} \textit{Vitest} v3.2.3 - Framework de testing para \textit{Vite}
    \item \textbf{Frontend:} \textit{Jest} v30.0.3 - Framework de testing para \textit{React}
    \item \textbf{\textit{Smart Contracts}:} \textit{Hardhat Testing} - Framework integrado de \textit{Hardhat}
    \item \textbf{Aserciones:} \textit{Chai} v4.5.0 - Librería de aserciones
    \item \textbf{Testing de \textit{UI}:} \textit{React Testing Library} v16.3.0 - Testing de componentes \textit{React}
\end{itemize}

\subsection{Capa pública Ethereum}

La arquitectura de la capa pública se describe en detalle en la sección Diseño del prototipo. Esta sección se enfoca en los aspectos específicos de implementación técnica.

\subsubsection{Desarrollo del smart contract}

El \textit{Smart Contract} FineManagement.sol implementa la lógica de negocio para la gestión pública de infracciones de tránsito. El contrato se desarrolló en \textit{Solidity} v0.8.28 y hereda de \textit{Ownable} (\textit{OpenZeppelin}) para control de acceso.

\paragraph{Estructura de datos}
El contrato define dos estructuras principales para modelar las multas y su historial de estados:

\begin{verbatim}
enum FineState {
    PENDING,
    PAID,
    APPEALED,
    RESOLVED_APPEAL,
    CANCELLED
}
\end{verbatim}

Este enum define los cinco estados que el \textit{smart contract} del prototipo implementa como prueba de concepto. Es importante destacar que el código utiliza nomenclatura en inglés siguiendo las mejores prácticas de la industria del desarrollo de \textit{software} \textit{blockchain}, donde \textit{Solidity} y \textit{Ethereum} tienen convenciones establecidas en este idioma.

La Tabla~\ref{tab:mapeo_estados} presenta el mapeo sistemático entre estos estados implementados en el \textit{smart contract} (inglés) y los estados conceptuales del proceso de fotocomparendos descritos en la Introducción (sección 1.2). Como se observa en la tabla, el prototipo implementa un subconjunto funcional de los ocho estados conceptuales completos, siendo suficiente para validar los principios de inmutabilidad y trazabilidad. Los estados NOTIFICADA y CERRADA no fueron implementados en esta versión pero pueden agregarse en una implementación de producción sin modificaciones arquitectónicas sustanciales.

\input{tables/mapeo_estados}

\begin{verbatim}
struct Fine {
    uint256 id;
    string plateNumber;
    string evidenceCID;        // \textit{CID} de \textit{IPFS} público
    string location;
    uint256 timestamp;
    string infractionType;
    uint256 cost;
    string ownerIdentifier;
    FineState currentState;
    address registeredBy;
    string externalSystemId;   // ID del \textit{SIMIT}
}

struct FineStatusUpdate {
    uint256 lastUpdatedTimestamp;
    FineState oldState;
    FineState newState;
    string reason;
    address updatedBy;
}
\end{verbatim}

\paragraph{Mapeos para consultas eficientes}
Para optimizar las consultas se implementaron mapeos especializados:

\begin{verbatim}
mapping(uint256 => Fine) public fines;
mapping(uint256 => FineStatusUpdate[]) public fineStatusHistory;
mapping(string => uint256[]) public finesByPlate;
mapping(string => uint256[]) public finesByOwner;
mapping(address => bool) public operators;
\end{verbatim}

\paragraph{Funciones principales}
Las funciones críticas del contrato garantizan la inmutabilidad y trazabilidad:

\begin{itemize}
    \item \texttt{registerFine()}: Registra una nueva multa con validaciones de entrada. Incrementa el contador de IDs, almacena la estructura Fine en el mapping, actualiza los índices de búsqueda por placa y propietario, y emite el evento FineRegistered.
    
    \item \texttt{updateFineStatus()}: Actualiza el estado de una multa existente. Valida que la multa exista y que el nuevo estado sea diferente al actual, registra el cambio en el historial y emite el evento FineStatusUpdated.
    
    \item \texttt{getFineDetails()}: Retorna los detalles completos de una multa dado su ID.
    
    \item \texttt{getFinesByPlate()}: Retorna un array de IDs de multas asociadas a un número de placa específico.
    
    \item \texttt{getPaginatedFines()}: Implementa paginación eficiente para consultas de múltiples multas, evitando problemas de límite de gas en consultas grandes.
    
    \item \texttt{getFineStatusHistory()}: Retorna el historial paginado de cambios de estado de una multa, permitiendo auditoría completa de su ciclo de vida.
\end{itemize}

\paragraph{Control de acceso}
El contrato implementa un sistema de roles mediante el modificador \texttt{onlyOperator}, que restringe operaciones críticas (registro y actualización de multas) a direcciones autorizadas. El propietario del contrato puede agregar o remover operadores mediante las funciones \texttt{addOperator()} y \texttt{removeOperator()}.

\paragraph{Eventos para auditoría}
Se definieron eventos para facilitar la auditoría externa:

\begin{verbatim}
event FineRegistered(
    uint256 indexed fineId,
    string indexed plateNumber,
    string evidenceCID,
    string ownerIdentifier,
    uint256 cost,
    uint256 timestamp
);

event FineStatusUpdated(
    uint256 indexed fineId,
    FineState indexed oldState,
    FineState indexed newState,
    string reason,
    uint256 timestamp
);
\end{verbatim}

Estos eventos permiten que aplicaciones externas puedan suscribirse a cambios en tiempo real y mantener bases de datos sincronizadas sin necesidad de polling.

\subsubsection{Despliegue y configuración}

\paragraph{Configuración de Hardhat}
El framework \textit{Hardhat} se configuró para soportar despliegue en múltiples redes:

\begin{verbatim}
module.exports = {
  solidity: {
    version: "0.8.28",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    localhost: {
      url: "http://127.0.0.1:8545"
    },
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL,
      accounts: [process.env.PRIVATE_KEY]
    }
  }
};
\end{verbatim}

El optimizador de \textit{Solidity} se habilitó con 200 runs, priorizando la eficiencia de ejecución sobre el tamaño del bytecode desplegado.

\paragraph{Script de despliegue}
Se implementó un script automatizado para el despliegue del contrato:

\begin{verbatim}
// scripts/deploy.mjs
async function main() {
  const FineManagement = await ethers.getContractFactory(
    "FineManagement"
  );
  const fineManagement = await FineManagement.deploy();
  await fineManagement.waitForDeployment();
  
  const address = await fineManagement.getAddress();
  console.log(`FineManagement deployed to: ${address}`);
}
\end{verbatim}

\paragraph{Red de despliegue}
El prototipo se desplegó inicialmente en la red local de \textit{Hardhat} para desarrollo y pruebas. Para demostración pública, se configuró el despliegue en \textit{Sepolia Testnet}, una red de pruebas de \textit{Ethereum} que permite validación externa sin costos reales.

\subsubsection{Configuración de infraestructura}

\paragraph{Configuración de Hyperledger Fabric}
La red privada se orquestó mediante \textit{Docker Compose} con tres organizaciones (Secretaría de Movilidad, Policía de Tránsito, Auditoría) y un nodo \textit{orderer} con consenso \textit{Raft}. La configuración incluye \textit{Certificate Authorities} por organización y canales privados para separación de datos sensibles.

\paragraph{Configuración de IPFS}
Se implementó un nodo \textit{IPFS} local (\textit{Kubo} v0.34.1) con \textit{API HTTP} habilitado para almacenamiento de evidencias. La configuración incluye \textit{pinning} automático y control de acceso restringido al backend.

\subsubsection{Instalación y despliegue}

\paragraph{Prerrequisitos del sistema}
El prototipo requiere Ubuntu 22.04 LTS o superior con las siguientes dependencias:
\begin{itemize}
    \item \textbf{\textit{Node.js}:} v20.18.0+ con npm v10.0.0+
    \item \textbf{\textit{Docker}:} v24.0+ con \textit{Docker Compose} v2.20+
    \item \textbf{\textit{IPFS Kubo}:} v0.34.1+ para almacenamiento descentralizado
    \item \textbf{Git:} Para clonado de repositorios
\end{itemize}

\paragraph{Proceso de instalación}
La instalación se realiza mediante los siguientes pasos:

\begin{enumerate}
    \item \textbf{Clonar repositorios:}
    \begin{verbatim}
    git clone https://github.com/CristianGT089/backend-multas
    git clone https://github.com/k-delta/fotomultas-front
    \end{verbatim}
    
    \item \textbf{Configurar backend:}
    \begin{verbatim}
    cd backend-multas
    npm install
    cp env.example .env
    # Editar .env con configuración local
    \end{verbatim}
    
    \item \textbf{Iniciar servicios:}
    \begin{verbatim}
    # Terminal 1: IPFS
    ipfs daemon &
    
    # Terminal 2: Hardhat
    npm run dev:contracts
    
    # Terminal 3: Backend
    npm run dev
    \end{verbatim}
    
    \item \textbf{Configurar frontend:}
    \begin{verbatim}
    cd ../fotomultas-front
    npm install
    npm run dev
    \end{verbatim}
\end{enumerate}

\paragraph{Verificación del despliegue}
El sistema estará disponible en:
\begin{itemize}
    \item \textbf{Frontend:} http://localhost:5173
    \item \textbf{Backend API:} http://localhost:3000
    \item \textbf{Documentación Swagger:} http://localhost:3000/api-docs
    \item \textbf{IPFS Gateway:} http://localhost:5001
\end{itemize}

\subsection{Capa privada Hyperledger Fabric}

La arquitectura de la capa privada y su justificación técnica se detallan en la sección Metodología y la sección Diseño del prototipo. Esta sección describe la configuración técnica específica implementada.

\subsubsection{Configuración de la red}

La red de \textit{Hyperledger Fabric} se configuró con la siguiente topología:

\begin{itemize}
    \item \textbf{Organizaciones:} Tres organizaciones (Secretaría de Movilidad, Policía de Tránsito, Auditoría)
    \item \textbf{Peers:} Dos nodos \textit{peer} por organización para redundancia
    \item \textbf{\textit{Orderer}:} Un nodo \textit{orderer} con consenso \textit{Raft}
    \item \textbf{Canal:} Un canal llamado \texttt{fotomultas-channel} compartido por las tres organizaciones
    \item \textbf{\textit{Certificate Authority}:} Una \textit{CA} por organización para gestión de identidades
\end{itemize}

La configuración se definió mediante archivos \textit{YAML} estándar de \textit{Fabric}: \texttt{configtx.yaml} para la configuración del canal, \texttt{crypto-config.yaml} para la generación de certificados y \texttt{docker-compose.yaml} para la orquestación de contenedores.

\subsubsection{Desarrollo del chaincode}

El \textit{chaincode} se implementó en \textit{Go}, siguiendo la estructura de \texttt{contractapi.Contract} de \textit{Hyperledger Fabric}. Las funciones principales incluyen:

\begin{itemize}
    \item \texttt{RegisterInternalFine()}: Registra una multa completa con datos sensibles en la blockchain privada. Almacena información del conductor, detalles de la evidencia completa y notas internas.
    
    \item \texttt{UpdateFineStatus()}: Actualiza el estado de una multa y registra el cambio en el historial privado.
    
    \item \texttt{ProcessAppeal()}: Gestiona el proceso de apelación, almacenando las evidencias presentadas por el ciudadano y la resolución del agente.
    
    \item \texttt{GetFineDetails()}: Retorna los detalles completos de una multa, incluyendo información sensible accesible solo para usuarios autorizados.
    
    \item \texttt{AuditTrail()}: Proporciona un historial de auditoría completo de todas las operaciones realizadas sobre una multa específica.
\end{itemize}

\paragraph{Gestión de datos privados}
Se utilizó la funcionalidad de \textit{Private Data Collections} de \textit{Fabric} para separar información altamente sensible (como datos de identificación del conductor) que solo debe ser accesible por la organización que la registró.

\paragraph{Control de acceso basado en atributos}
El chaincode implementa validaciones basadas en los atributos del certificado del invocador, verificando roles (agente, administrador, auditor) antes de permitir operaciones sensibles.

\subsection{Sincronización entre blockchains}

\subsubsection{Arquitectura del servicio}

El servicio de sincronización se implementó como un proceso independiente en \textit{Node.js} que escucha eventos de la blockchain privada (\textit{Hyperledger Fabric}) y sincroniza metadatos públicos a la blockchain pública (\textit{Ethereum}).

\paragraph{Componentes principales}
\begin{itemize}
    \item \textbf{\textit{Event Listener}:} Módulo que se suscribe a eventos del \textit{chaincode} de \textit{Fabric}
    \item \textbf{\textit{Metadata Extractor}:} Componente que filtra datos sensibles y extrae solo metadatos públicos
    \item \textbf{\textit{Hash Generator}:} Genera \textit{hash} \textit{SHA-256} de integridad del registro completo
    \item \textbf{\textit{Ethereum Publisher}:} Publica los metadatos en el \textit{Smart Contract} de \textit{Ethereum}
    \item \textbf{\textit{Consistency Validator}:} Verifica que los datos se sincronizaron correctamente
\end{itemize}

\subsubsection{Flujo de sincronización}

El proceso de sincronización sigue estos pasos:

\begin{enumerate}
    \item El \textit{chaincode} de \textit{Fabric} emite un evento \texttt{FineRegistered} o \texttt{FineUpdated}
    \item El \textit{Event Listener} captura el evento y extrae el ID de la multa
    \item Se consulta el registro completo desde \textit{Fabric}
    \item El \textit{Metadata Extractor} genera la estructura pública:
    \begin{itemize}
        \item ID de multa
        \item Número de placa
        \item \textit{Hash} de evidencia (\textit{CID} de \textit{IPFS} público)
        \item Ubicación
        \item Tipo de infracción
        \item Costo
        \item Timestamp
        \item Estado actual
    \end{itemize}
    \item Se genera un \textit{hash} de integridad del registro completo privado
    \item Se publica el registro público en \textit{Ethereum} mediante \texttt{registerPublicFine()}
    \item Se valida que el \textit{transaction hash} de \textit{Ethereum} sea exitoso
    \item Se registra la sincronización en un log de auditoría
\end{enumerate}

\subsubsection{Manejo de errores y reintentos}

El servicio implementa un mecanismo de reintentos con backoff exponencial para manejar fallas temporales de red o gas insuficiente en Ethereum. Los eventos fallidos se encolan para reintento posterior, garantizando eventual consistencia.

\subsection{Implementación de IPFS dual}

\subsubsection{IPFS privado}

Se configuró un nodo IPFS local para el almacenamiento de evidencias completas:

\begin{itemize}
    \item \textbf{Configuración:} Nodo \textit{Kubo} v0.34.1 con \textit{API HTTP} habilitado solo para localhost
    \item \textbf{Estrategia de \textit{Pinning}:} \textit{Pinning} automático de todas las evidencias subidas
    \item \textbf{Control de Acceso:} \textit{API} accesible solo desde el backend, sin exposición pública
    \item \textbf{Persistencia:} Almacenamiento en disco local con respaldo periódico
\end{itemize}

El servicio IPFSPrivateService implementa las siguientes funciones:

\begin{itemize}
    \item \texttt{uploadToIPFS(fileBuffer, fileName)}: Sube una evidencia completa y retorna su \textit{CID}
    \item \texttt{getFromIPFS(cid)}: Recupera un archivo dado su \textit{CID}
    \item \texttt{isConnected()}: Verifica la conectividad con el daemon de IPFS
\end{itemize}

\subsubsection{IPFS público}

Para la capa pública se utilizó un gateway público de IPFS que permite:

\begin{itemize}
    \item Publicación de \textit{hashes} de evidencias para verificación ciudadana
    \item Acceso sin autenticación a través de \textit{HTTP}
    \item Verificación de integridad mediante comparación de \textit{CIDs}
\end{itemize}

El IPFSPublicService gestiona la publicación de hashes en el nodo público, manteniendo la separación entre evidencias completas (privadas) y hashes verificables (públicos).

\subsection{Desarrollo del backend}

\subsubsection{Arquitectura de servicios}

El backend implementa el patrón Controller-Service-Repository adaptado para arquitectura híbrida:

\paragraph{Capa de controladores}
\texttt{FineController} maneja las peticiones HTTP y delega la lógica de negocio a los servicios.

\paragraph{Capa de servicios}
\begin{itemize}
    \item \texttt{FineService}: Orquestador principal que coordina operaciones entre blockchains
    \item \texttt{HyperledgerService}: Interacción con la red privada de \textit{Fabric}
    \item \texttt{EthereumService}: (Implementado como \texttt{BlockchainService}) Interacción con \textit{Ethereum}
    \item \texttt{IPFSPrivateService}: Gestión de evidencias en IPFS privado
    \item \texttt{IPFSPublicService}: Gestión de hashes en IPFS público
    \item \texttt{AptitudeService}: Integración con API externa RUNT/SIMIT (simulada)
\end{itemize}

\paragraph{Capa de repositorios}
Los repositorios abstraen el acceso a las fuentes de datos (blockchains e IPFS).

\subsubsection{Endpoints principales}

La Tabla~\ref{tab:endpoints_api} describe los endpoints principales implementados en la API REST para la gestión de fotocomparendos.

\input{tables/endpoints_api.tex}

\subsubsection{Middleware de seguridad}

Se implementaron middlewares para:
\begin{itemize}
    \item Autenticación mediante \textit{JSON Web Tokens} (\textit{JWT})
    \item Validación de datos con \textit{express-validator}
    \item Control de acceso basado en roles (administrador, agente, ciudadano)
    \item \textit{Rate limiting} para prevenir abuso de la \textit{API}
    \item \textit{CORS} configurado para permitir solo orígenes autorizados
\end{itemize}

\subsubsection{Documentación con Swagger}

La \textit{API} se documentó utilizando \textit{Swagger}/\textit{OpenAPI} 3.0, generando documentación interactiva accesible en \texttt{/api-docs}. La documentación incluye:
\begin{itemize}
    \item Descripción de cada endpoint
    \item Esquemas de Request y Response
    \item Ejemplos de uso
    \item Códigos de error posibles
\end{itemize}

\subsection{Interfaz de usuario}

\subsubsection{Arquitectura de componentes}

El frontend se estructuró en tres módulos principales:

\paragraph{Panel de agente de tránsito}
Interfaz para registro y gestión de multas con las siguientes funcionalidades:
\begin{itemize}
    \item Formulario de registro de multa con validación en tiempo real
    \item Upload de evidencia fotográfica con preview
    \item Consulta de datos del RUNT (número de placa)
    \item Actualización de estado de multas existentes
    \item Visualización de historial de cambios
\end{itemize}

% Figura del Panel de Agente: (eliminada del PDF)
% Se comenta la figura para que no aparezca en la lista de figuras ni en el documento final.
% \begin{figure}[htbp]
%     \centering
%     % \includegraphics[width=0.8\textwidth]{Images/UI_Panel_Agente.png}
%     \caption{Panel de Agente de Tránsito - Registro de Multa}
%     \label{fig:ui_panel_agente}
% \end{figure}

\paragraph{Panel ciudadano}
Interfaz pública para consulta y verificación de multas:
\begin{itemize}
    \item Búsqueda de multas por número de placa
    \item Visualización de metadatos públicos desde Ethereum
    \item Verificación de integridad de evidencias
    \item Comparación de hash IPFS con registro blockchain
    \item Presentación de apelaciones (integrado con Fabric)
\end{itemize}

% Figura del Panel Ciudadano: (eliminada del PDF)
% Se comenta la figura para que no aparezca en la lista de figuras ni en el documento final.
% \begin{figure}[htbp]
%     \centering
%     % \includegraphics[width=0.8\textwidth]{Images/UI_Panel_Ciudadano.png}
%     \caption{Panel Ciudadano - Consulta y Verificación de Multas}
%     \label{fig:ui_panel_ciudadano}
% \end{figure}

\paragraph{Dashboard administrativo}
Panel con estadísticas y visualizaciones:
\begin{itemize}
    \item Gráficos de multas por tipo de infracción (Recharts)
    \item Estadísticas de estados de multas
    \item Historial de operaciones en ambas blockchains
    \item Métricas de rendimiento del sistema
\end{itemize}

% Figura del Dashboard Administrativo: (eliminada del PDF)
% Se comenta la figura para que no aparezca en la lista de figuras ni en el documento final.
% \begin{figure}[htbp]
%     \centering
%     % \includegraphics[width=0.8\textwidth]{Images/UI_Dashboard.png}
%     \caption{Dashboard Administrativo - Estadísticas y Métricas}
%     \label{fig:ui_dashboard}
% \end{figure}

\subsubsection{Gestión de estado}

Se implementó Zustand para gestión de estado global, con stores separados para:
\begin{itemize}
    \item Estado de autenticación del usuario
    \item Caché de multas consultadas
    \item Estado de sincronización blockchain
    \item Configuración de la aplicación
\end{itemize}

\subsubsection{Interacción con backend}

El frontend se comunica con el backend mediante:
\begin{itemize}
    \item Cliente Axios configurado con interceptores para manejo de tokens
    \item Caché de peticiones para reducir llamadas redundantes
    \item Manejo de errores centralizado con notificaciones al usuario
    \item Polling para actualización de estados de transacciones blockchain
\end{itemize}

\subsection{Integración con sistemas externos}

\subsubsection{Simulación de APIs gubernamentales}

Dado que las APIs reales del RUNT y SIMIT requieren contratos comerciales y aprobaciones institucionales, se implementaron servicios mock que simulan las respuestas esperadas:

\paragraph{API Aptitude (RUNT/SIMIT simulado)}
El servicio \texttt{AptitudeService} genera datos sintéticos coherentes para:
\begin{itemize}
    \item Información de propietarios de vehículos
    \item Datos del conductor
    \item Historial de infracciones previas
    \item Estado de multas en SIMIT
\end{itemize}

La simulación incluye validaciones realistas como verificación de formato de placa, generación de números de cédula coherentes y tipos de vehículos válidos según normativa colombiana.

\subsubsection{Consideraciones para integración real}

Para migrar a producción con APIs reales, se requiere:
\begin{itemize}
    \item Firma de convenio con entidades gubernamentales
    \item Obtención de credenciales API (API keys)
    \item Configuración de IPs autorizadas
    \item Implementación de rate limiting acorde a límites contractuales
    \item Manejo de timeouts y reintentos para servicios externos
\end{itemize}

El diseño modular del servicio permite reemplazar fácilmente los mocks por implementaciones reales sin afectar el resto del sistema.

\subsection{Desafíos técnicos}

\subsubsection{Compatibilidad de Módulos ESM}

\textbf{Problema:} La migración a ECMAScript Modules (\texttt{"type": "module"}) generó incompatibilidades con librerías que solo soportan CommonJS.

\textbf{Solución:} Se configuró Hardhat con archivo \texttt{.cjs} mientras el resto del proyecto usa ESM. Se actualizaron imports dinámicos donde fue necesario y se utilizó TypeScript para generar módulos compatibles.

\subsubsection{Optimización de Gas en Ethereum}

\textbf{Problema:} La función \texttt{getPaginatedFines()} consumía gas excesivo al iterar sobre arrays grandes.

\textbf{Solución:} Se optimizó el código Solidity para minimizar lecturas de storage, se implementó paginación eficiente y se habilitó el optimizador del compilador con 200 runs.

\subsubsection{Sincronización Asíncrona}

\textbf{Problema:} La sincronización entre Fabric y Ethereum es asíncrona, creando ventanas de inconsistencia temporal.

\textbf{Solución:} Se implementó un sistema de eventos que notifica al frontend cuando la sincronización se completa. Se agregó un campo de estado de sincronización en el backend que indica si un registro está "pendiente de sincronización" o "sincronizado".

\subsubsection{Manejo de Archivos Grandes en IPFS}

\textbf{Problema:} Upload de evidencias mayores a 10MB causaba timeouts en el cliente.

\textbf{Solución:} Se implementó límite de tamaño de 5MB por evidencia en el backend. Se agregó compresión de imágenes en el frontend antes del upload. Para videos, se extrae un frame representativo en lugar de subir el archivo completo.

\subsection{Estrategia de validación}

La validación del prototipo se realizó siguiendo el plan de pruebas detallado en la sección Plan de pruebas. La implementación incluyó la configuración de frameworks de testing en tres niveles:

\begin{itemize}
    \item \textbf{Smart Contracts:} Hardhat Test Framework con Chai para aserciones
    \item \textbf{Backend:} Vitest v3.2.4 para pruebas de API REST e integración con blockchain
    \item \textbf{Frontend:} Jest v30.0.3 y React Testing Library v16.3.0 para pruebas de componentes
\end{itemize}

Los resultados detallados de todas las pruebas ejecutadas, incluyendo cobertura de código, casos de prueba específicos y métricas de rendimiento, se presentan en la sección Resultados de las pruebas de inmutabilidad y verificabilidad del prototipo.
