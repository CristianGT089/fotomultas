\section{Anexos}

\subsection{Anexo A: Código Fuente Relevante}

\subsubsection{Smart Contract FineManagement.sol (Extracto Comentado)}

\begin{verbatim}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title FineManagement
 * @dev Smart Contract para gestión pública de fotomultas en Ethereum
 * @notice Este contrato almacena metadatos públicos de multas para
 * verificación ciudadana sin comprometer datos sensibles
 */
contract FineManagement is Ownable {
    uint256 private _fineIds;

    // Estados posibles de una multa
    enum FineState { 
        PENDING,          // Registrada, pendiente de notificación
        PAID,             // Pagada completamente
        APPEALED,         // En proceso de apelación
        RESOLVED_APPEAL,  // Apelación resuelta
        CANCELLED         // Anulada por error
    }

    // Estructura de datos pública de una multa
    struct Fine {
        uint256 id;
        string plateNumber;
        string evidenceCID;        // CID del hash en IPFS público
        string location;
        uint256 timestamp;
        string infractionType;
        uint256 cost;
        string ownerIdentifier;    // Identificador público (no DNI)
        FineState currentState;
        address registeredBy;      // Dirección del agente
        string externalSystemId;   // ID del SIMIT
    }

    // Historial de cambios de estado
    struct FineStatusUpdate {
        uint256 lastUpdatedTimestamp;
        FineState oldState;
        FineState newState;
        string reason;
        address updatedBy;
    }

    // Mapings para consultas eficientes
    mapping(uint256 => Fine) public fines;
    mapping(uint256 => FineStatusUpdate[]) public fineStatusHistory;
    mapping(string => uint256[]) public finesByPlate;
    mapping(address => bool) public operators;

    // Eventos para auditoría
    event FineRegistered(
        uint256 indexed fineId,
        string indexed plateNumber,
        string evidenceCID,
        string ownerIdentifier,
        uint256 cost,
        uint256 timestamp
    );

    event FineStatusUpdated(
        uint256 indexed fineId,
        FineState indexed oldState,
        FineState indexed newState,
        string reason,
        uint256 timestamp
    );

    /**
     * @dev Modificador que restringe acceso a operadores autorizados
     */
    modifier onlyOperator() {
        require(
            operators[msg.sender] || owner() == msg.sender,
            "Not an operator"
        );
        _;
    }

    /**
     * @dev Constructor: inicializa el owner como operador
     */
    constructor() Ownable(msg.sender) {
        operators[msg.sender] = true;
    }

    /**
     * @notice Registra una nueva multa (solo operadores)
     * @param _plateNumber Número de placa del vehículo
     * @param _evidenceCID CID del hash de evidencia en IPFS
     * @param _location Ubicación de la infracción
     * @param _infractionType Tipo de infracción (ej. "Exceso velocidad")
     * @param _cost Valor de la multa en pesos
     * @param _ownerIdentifier Identificador del propietario
     * @param _externalSystemId ID opcional del SIMIT
     * @return newFineId ID asignado a la nueva multa
     */
    function registerFine(
        string memory _plateNumber,
        string memory _evidenceCID,
        string memory _location,
        string memory _infractionType,
        uint256 _cost,
        string memory _ownerIdentifier,
        string memory _externalSystemId
    ) public onlyOperator returns (uint256) {
        // Validaciones de entrada
        require(bytes(_plateNumber).length > 0, 
                "Plate number is required");
        require(bytes(_evidenceCID).length > 0, 
                "Evidence CID is required");
        require(_cost > 0, "Cost must be greater than zero");

        // Incrementar contador e ID
        _fineIds += 1;
        uint256 newFineId = _fineIds;

        // Almacenar estructura de multa
        fines[newFineId] = Fine({
            id: newFineId,
            plateNumber: _plateNumber,
            evidenceCID: _evidenceCID,
            location: _location,
            timestamp: block.timestamp,
            infractionType: _infractionType,
            cost: _cost,
            ownerIdentifier: _ownerIdentifier,
            currentState: FineState.PENDING,
            registeredBy: msg.sender,
            externalSystemId: _externalSystemId
        });

        // Actualizar índices de búsqueda
        finesByPlate[_plateNumber].push(newFineId);

        // Registrar estado inicial en historial
        fineStatusHistory[newFineId].push(FineStatusUpdate({
            lastUpdatedTimestamp: block.timestamp,
            oldState: FineState.PENDING,
            newState: FineState.PENDING,
            reason: "Fine registered",
            updatedBy: msg.sender
        }));

        // Emitir evento
        emit FineRegistered(
            newFineId,
            _plateNumber,
            _evidenceCID,
            _ownerIdentifier,
            _cost,
            block.timestamp
        );

        return newFineId;
    }

    /**
     * @notice Actualiza el estado de una multa (solo operadores)
     * @param _fineId ID de la multa a actualizar
     * @param _newState Nuevo estado
     * @param _reason Razón del cambio
     */
    function updateFineStatus(
        uint256 _fineId,
        FineState _newState,
        string memory _reason
    ) public onlyOperator {
        Fine storage fine = fines[_fineId];
        require(fine.id != 0, "Fine does not exist");
        require(fine.currentState != _newState, 
                "State is already the same");

        FineState oldState = fine.currentState;
        fine.currentState = _newState;

        // Registrar cambio en historial
        fineStatusHistory[_fineId].push(FineStatusUpdate({
            lastUpdatedTimestamp: block.timestamp,
            oldState: oldState,
            newState: _newState,
            reason: _reason,
            updatedBy: msg.sender
        }));

        emit FineStatusUpdated(
            _fineId,
            oldState,
            _newState,
            _reason,
            block.timestamp
        );
    }

    /**
     * @notice Consulta pública de detalles de una multa
     * @param _fineId ID de la multa
     * @return fine Estructura completa de la multa
     */
    function getFineDetails(uint256 _fineId) 
        public view returns (Fine memory) 
    {
        require(fines[_fineId].id != 0, "Fine does not exist");
        return fines[_fineId];
    }

    /**
     * @notice Consulta pública por número de placa
     * @param _plateNumber Número de placa
     * @return Array de IDs de multas asociadas
     */
    function getFinesByPlate(string memory _plateNumber) 
        public view returns (uint256[] memory) 
    {
        return finesByPlate[_plateNumber];
    }
}
\end{verbatim}

\subsubsection{Servicio Backend: FineService.ts (Extracto)}

\begin{verbatim}
import { BlockchainService } from './blockchain.service';
import { IPFSService } from './ipfs.service';
import { AptitudeService } from './apitude.service';

/**
 * Servicio principal que orquesta las operaciones de multas
 * Coordina interacción con Ethereum, IPFS y APIs externas
 */
export class FineService {
  private blockchainService: BlockchainService;
  private ipfsService: IPFSService;
  private aptitudeService: AptitudeService;

  constructor() {
    this.blockchainService = BlockchainService.getInstance();
    this.ipfsService = IPFSService.getInstance();
    this.aptitudeService = AptitudeService.getInstance();
  }

  /**
   * Registra una nueva multa completa:
   * 1. Upload de evidencia a IPFS
   * 2. Registro en Ethereum
   * 3. (Futuro) Sincronización con Hyperledger
   */
  async registerFine(
    file: Express.Multer.File, 
    fineData: IFineDetails
  ): Promise<{ fineId: string; txHash: string; cid: string }> {
    // 1. Subir evidencia a IPFS
    const cid = await this.ipfsService.uploadToIPFS(
      file.buffer, 
      file.originalname
    );

    // 2. Consultar datos del RUNT (simulado)
    const vehicleData = await this.aptitudeService
      .fetchFineFromAptitude(
        fineData.plateNumber, 
        new Date().toISOString()
      );

    // 3. Registrar en Ethereum
    const tx = await this.blockchainService.registerFine({
      ...fineData,
      evidenceCID: cid,
      ownerIdentifier: vehicleData.ownerName
    });

    return {
      fineId: tx.fineId.toString(),
      txHash: tx.txHash,
      cid: cid
    };
  }

  /**
   * Verifica integridad cruzada entre blockchain e IPFS
   */
  async verifyIntegrity(
    fineId: string
  ): Promise<{ isValid: boolean; cid: string }> {
    // Obtener CID almacenado en blockchain
    const fine = await this.blockchainService
      .getFineDetails(fineId);
    
    // Verificar que el archivo existe en IPFS
    const exists = await this.ipfsService
      .verifyFileExists(fine.evidenceCID);

    return {
      isValid: exists,
      cid: fine.evidenceCID
    };
  }
}
\end{verbatim}

\subsubsection{Servicio IPFS: IPFSService.ts (Extracto)}

\begin{verbatim}
import { create, IPFSHTTPClient } from 'ipfs-http-client';

/**
 * Servicio para interacción con IPFS
 * Maneja upload y recuperación de evidencias
 */
export class IPFSService {
  private static instance: IPFSService;
  private ipfs: IPFSHTTPClient;

  private constructor() {
    this.ipfs = create({ 
      url: process.env.IPFS_API_URL || 'http://127.0.0.1:5001' 
    });
  }

  static getInstance(): IPFSService {
    if (!IPFSService.instance) {
      IPFSService.instance = new IPFSService();
    }
    return IPFSService.instance;
  }

  /**
   * Sube un archivo a IPFS y retorna su CID
   * @param fileBuffer Buffer del archivo
   * @param fileName Nombre del archivo
   * @returns Content Identifier (CID) del archivo
   */
  async uploadToIPFS(
    fileBuffer: Buffer, 
    fileName: string
  ): Promise<string> {
    const { cid } = await this.ipfs.add(fileBuffer, {
      pin: true,  // Mantener el archivo en el nodo
      wrapWithDirectory: false
    });
    
    console.log(`Archivo ${fileName} subido a IPFS: ${cid}`);
    return cid.toString();
  }

  /**
   * Recupera un archivo desde IPFS dado su CID
   * @param cid Content Identifier
   * @returns Buffer del archivo
   */
  async getFromIPFS(cid: string): Promise<Uint8Array[]> {
    const chunks: Uint8Array[] = [];
    
    for await (const chunk of this.ipfs.cat(cid)) {
      chunks.push(chunk);
    }
    
    return chunks;
  }
}
\end{verbatim}

\subsection{Anexo B: Configuración de Infraestructura}

\subsubsection{Configuración de Hardhat (hardhat.config.cjs)}

\begin{verbatim}
require("@nomicfoundation/hardhat-toolbox");
require("dotenv").config();

module.exports = {
  solidity: {
    version: "0.8.28",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200  // Optimizado para ejecución frecuente
      }
    }
  },
  networks: {
    // Red local para desarrollo
    localhost: {
      url: "http://127.0.0.1:8545"
    },
    // Red de prueba Sepolia
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL,
      accounts: [process.env.PRIVATE_KEY],
      chainId: 11155111
    }
  },
  paths: {
    sources: "./contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts"
  }
};
\end{verbatim}

\subsubsection{Configuración de Docker Compose para Hyperledger Fabric}

\begin{verbatim}
version: '2'

networks:
  fotomultas:

services:
  # Certificate Authority
  ca.sdm.fotomultas.com:
    image: hyperledger/fabric-ca:latest
    environment:
      - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server
      - FABRIC_CA_SERVER_CA_NAME=ca-sdm
    volumes:
      - ./crypto-config/peerOrganizations/sdm.fotomultas.com/ca/:/
        etc/hyperledger/fabric-ca-server-config
    command: sh -c 'fabric-ca-server start -b admin:adminpw'
    networks:
      - fotomultas

  # Peer Node - Secretaría de Movilidad
  peer0.sdm.fotomultas.com:
    image: hyperledger/fabric-peer:latest
    environment:
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_PEER_ID=peer0.sdm.fotomultas.com
      - CORE_PEER_ADDRESS=peer0.sdm.fotomultas.com:7051
      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.sdm.fotomultas.com:7051
      - CORE_PEER_LOCALMSPID=SdmMSP
    volumes:
      - /var/run/:/host/var/run/
      - ./crypto-config/peerOrganizations/sdm.fotomultas.com/
        peers/peer0.sdm.fotomultas.com/msp:/
        etc/hyperledger/fabric/msp
    networks:
      - fotomultas

  # Orderer Node
  orderer.fotomultas.com:
    image: hyperledger/fabric-orderer:latest
    environment:
      - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0
      - ORDERER_GENERAL_GENESISMETHOD=file
      - ORDERER_GENERAL_GENESISFILE=/
        var/hyperledger/orderer/orderer.genesis.block
      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP
      - ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/
        var/hyperledger/orderer/tls/server.crt
      - ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/
        var/hyperledger/orderer/tls/server.key
    volumes:
      - ./channel-artifacts/genesis.block:/
        var/hyperledger/orderer/orderer.genesis.block
      - ./crypto-config/ordererOrganizations/fotomultas.com/
        orderers/orderer.fotomultas.com/msp:/
        var/hyperledger/orderer/msp
    networks:
      - fotomultas
\end{verbatim}

\subsection{Anexo C: Manual de Instalación}

\subsubsection{Prerrequisitos}

\begin{itemize}
    \item \textbf{Sistema Operativo:} Ubuntu 22.04 LTS o superior
    \item \textbf{Node.js:} Versión 20.18.0 o superior
    \item \textbf{npm:} Versión 10.0.0 o superior
    \item \textbf{Docker:} Versión 24.0+ con Docker Compose 2.20+
    \item \textbf{IPFS Kubo:} Versión 0.34.1 o superior
    \item \textbf{Git:} Para clonar repositorios
    \item \textbf{Go:} Versión 1.21+ (solo para desarrollo de chaincode)
\end{itemize}

\subsubsection{Paso 1: Instalación de Node.js}

\begin{verbatim}
# Instalar nvm (Node Version Manager)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/
install.sh | bash

# Recargar terminal
source ~/.bashrc

# Instalar Node.js 20.18.0
nvm install 20.18.0
nvm use 20.18.0

# Verificar instalación
node --version  # Debe mostrar v20.18.0
npm --version   # Debe mostrar 10.0.0 o superior
\end{verbatim}

\subsubsection{Paso 2: Instalación de IPFS}

\begin{verbatim}
# Descargar IPFS Kubo
wget https://dist.ipfs.tech/kubo/v0.34.1/
kubo_v0.34.1_linux-amd64.tar.gz

# Extraer archivo
tar -xvzf kubo_v0.34.1_linux-amd64.tar.gz

# Instalar
cd kubo
sudo bash install.sh

# Verificar instalación
ipfs --version

# Inicializar IPFS (solo primera vez)
ipfs init

# Iniciar daemon de IPFS
ipfs daemon &
\end{verbatim}

\subsubsection{Paso 3: Clonar e Instalar el Proyecto}

\begin{verbatim}
# Clonar repositorio
git clone <repository-url>
cd backend

# Instalar dependencias
npm install

# Copiar archivo de variables de entorno
cp env.example .env

# Editar .env con configuración local
nano .env
\end{verbatim}

\subsubsection{Paso 4: Configurar Variables de Entorno}

Editar el archivo \texttt{.env} con los siguientes valores:

\begin{verbatim}
# Servidor
PORT=3000

# Blockchain (Hardhat)
RPC_URL=http://127.0.0.1:8545
PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
CONTRACT_ADDRESS=  # Se obtiene después del despliegue

# IPFS
IPFS_API_URL=http://127.0.0.1:5001

# APIs Externas (opcional para simulación)
SIMIT_API_BASE_URL=https://api.simit.com
SIMIT_API_KEY=your_api_key_here
\end{verbatim}

\subsubsection{Paso 5: Compilar y Desplegar Smart Contracts}

\begin{verbatim}
# Terminal 1: Compilar contratos
npm run build:contracts

# Terminal 2: Iniciar nodo local de Hardhat
npm run dev:contracts

# Terminal 3: Desplegar contratos
npm run deploy

# Copiar la dirección del contrato desplegado y 
# agregarla al archivo .env como CONTRACT_ADDRESS
\end{verbatim}

\subsubsection{Paso 6: Iniciar el Backend}

\begin{verbatim}
# Iniciar servidor de desarrollo (con recarga automática)
npm run dev

# El servidor estará disponible en http://localhost:3000
# Documentación Swagger en http://localhost:3000/api-docs
\end{verbatim}

\subsubsection{Paso 7: Iniciar el Frontend}

\begin{verbatim}
# En directorio del frontend
cd ../fotomultas-front

# Instalar dependencias
npm install

# Iniciar servidor de desarrollo
npm run dev

# El frontend estará disponible en http://localhost:5173
\end{verbatim}

\subsubsection{Verificación de la Instalación}

\begin{verbatim}
# Verificar conectividad con IPFS
curl http://localhost:5001/api/v0/version

# Verificar que Hardhat está corriendo
curl -X POST --data '{"jsonrpc":"2.0","method":"eth_blockNumber",
"params":[],"id":1}' http://localhost:8545

# Verificar backend
curl http://localhost:3000/api-docs

# Verificar frontend
curl http://localhost:5173
\end{verbatim}

\subsection{Anexo D: Manual de Usuario}

\subsubsection{Manual para Agentes de Tránsito}

\paragraph{1. Iniciar Sesión.}
\begin{itemize}
    \item Acceder a la URL del sistema
    \item Ingresar credenciales proporcionadas por el administrador
    \item Seleccionar rol "Agente de Tránsito"
\end{itemize}

\paragraph{2. Registrar una Multa.}
\begin{itemize}
    \item En el menú principal, seleccionar "Registrar Multa"
    \item Completar el formulario con:
    \begin{itemize}
        \item Número de placa del vehículo
        \item Tipo de infracción (seleccionar de lista desplegable)
        \item Ubicación (GPS automático o manual)
        \item Costo de la multa (calculado automáticamente según tipo)
    \end{itemize}
    \item Cargar evidencia fotográfica (máximo 5MB, formato JPG/PNG)
    \item Hacer clic en "Registrar Multa"
    \item Esperar confirmación de blockchain (aprox. 2-5 segundos)
    \item Anotar el ID de multa generado para referencia
\end{itemize}

% Espacio reservado para captura de pantalla del proceso
\begin{figure}[htbp]
    \centering
    % \includegraphics[width=0.7\textwidth]{Images/UI_Registro_Multa.png}
    \caption{Pantalla de Registro de Multa - Panel del Agente}
\end{figure}

\paragraph{3. Actualizar Estado de Multa.}
\begin{itemize}
    \item Buscar multa por ID o número de placa
    \item Seleccionar "Actualizar Estado"
    \item Elegir nuevo estado (Pagada, En Apelación, etc.)
    \item Ingresar razón del cambio
    \item Confirmar actualización
\end{itemize}

\subsubsection{Manual para Ciudadanos}

\paragraph{1. Consultar Multas.}
\begin{itemize}
    \item Acceder a la sección pública (sin autenticación requerida)
    \item Ingresar número de placa del vehículo
    \item Hacer clic en "Buscar"
    \item Revisar lista de multas asociadas
\end{itemize}

% Espacio reservado para captura de pantalla
\begin{figure}[htbp]
    \centering
    % \includegraphics[width=0.7\textwidth]{Images/UI_Consulta_Ciudadano.png}
    \caption{Pantalla de Consulta Pública - Panel Ciudadano}
\end{figure}

\paragraph{2. Verificar Integridad de Evidencia.}
\begin{itemize}
    \item Seleccionar una multa de la lista
    \item Hacer clic en "Verificar Integridad"
    \item El sistema compara el hash de la evidencia en blockchain 
          con el archivo en IPFS
    \item Se muestra resultado: "Evidencia Verificada" o 
          "Evidencia Alterada"
\end{itemize}

\paragraph{3. Presentar Apelación.}
\begin{itemize}
    \item Crear cuenta en el sistema (requiere verificación de identidad)
    \item Seleccionar multa a apelar
    \item Completar formulario de apelación con argumentos
    \item Cargar evidencias de respaldo (opcional)
    \item Enviar apelación
    \item Esperar notificación de resolución (máximo 30 días hábiles)
\end{itemize}

\subsection{Anexo E: Glosario de Términos}

\begin{longtable}{|p{3.5cm}|p{10.5cm}|}
\caption{Glosario de Términos Técnicos} \\
\hline
\textbf{Término} & \textbf{Definición} \\ \hline
\endfirsthead

\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- continuación de la página anterior}} \\
\hline
\textbf{Término} & \textbf{Definición} \\ \hline
\endhead

\hline \multicolumn{2}{r}{{}} \\ \hline
\endfoot

\hline
\endlastfoot
ABI (Application Binary Interface) & Interfaz que define cómo llamar funciones de un Smart Contract desde aplicaciones externas. Contiene nombres de funciones, parámetros y tipos de retorno. \\ \hline
Blockchain & Tecnología de registro distribuido que almacena datos en bloques encadenados mediante hashes criptográficos, garantizando inmutabilidad. \\ \hline
CA (Certificate Authority) & Entidad que emite y gestiona certificados digitales en una red Hyperledger Fabric, controlando identidades y permisos. \\ \hline
Chaincode & Smart Contract en el contexto de Hyperledger Fabric, generalmente escrito en Go, que define la lógica de negocio. \\ \hline
CID (Content Identifier) & Hash único que identifica un archivo en IPFS. Se genera mediante criptografía del contenido del archivo. \\ \hline
Consenso & Mecanismo mediante el cual los nodos de una blockchain acuerdan la validez de las transacciones. Ejemplos: PBFT, PoS, PoW. \\ \hline
DLT (Distributed Ledger Technology) & Tecnología de libro mayor distribuido que mantiene registros sincronizados entre múltiples nodos sin autoridad central. \\ \hline
Ethers.js & Biblioteca JavaScript para interactuar con la blockchain de Ethereum, permitiendo leer datos y enviar transacciones. \\ \hline
Gas & Unidad de medida del costo computacional en Ethereum. Cada operación consume gas que se paga en Ether. \\ \hline
Hardhat & Framework de desarrollo para Ethereum que facilita compilación, testing y despliegue de Smart Contracts. \\ \hline
Hash Criptográfico & Función matemática que convierte datos de cualquier tamaño en una cadena de longitud fija. Ejemplos: SHA-256, Keccak-256. \\ \hline
Hyperledger Fabric & Plataforma de blockchain permisionada empresarial, parte del proyecto Hyperledger de Linux Foundation. \\ \hline
Inmutabilidad & Propiedad de blockchain que garantiza que datos una vez escritos no pueden ser alterados sin dejar evidencia. \\ \hline
IPFS (InterPlanetary File System) & Sistema de archivos peer-to-peer distribuido que usa direccionamiento por contenido mediante CIDs. \\ \hline
Ledger & Libro mayor que registra todas las transacciones en una blockchain. Es distribuido y sincronizado entre nodos. \\ \hline
Nodo (Node) & Computadora que participa en una red blockchain, manteniendo una copia del ledger y validando transacciones. \\ \hline
OpenZeppelin & Librería de Smart Contracts auditados y seguros para Ethereum, proporciona implementaciones estándar de tokens, control de acceso, etc. \\ \hline
Orderer & Nodo en Hyperledger Fabric que ordena transacciones y las agrupa en bloques para distribuir a los peers. \\ \hline
PBFT (Practical Byzantine Fault Tolerance) & Algoritmo de consenso tolerante a fallas bizantinas usado en Hyperledger Fabric, eficiente para redes permisionadas. \\ \hline
Peer & Nodo en Hyperledger Fabric que mantiene una copia del ledger y ejecuta chaincode. \\ \hline
Pinning & En IPFS, mantener un archivo almacenado permanentemente en un nodo para garantizar su disponibilidad. \\ \hline
PoS (Proof of Stake) & Mecanismo de consenso donde validadores son seleccionados según la cantidad de criptomoneda que poseen. \\ \hline
PoW (Proof of Work) & Mecanismo de consenso que requiere resolver acertijos criptográficos complejos para validar bloques. \\ \hline
Private Data Collections & Funcionalidad de Hyperledger Fabric para almacenar datos privados que solo ciertos nodos pueden acceder. \\ \hline
Smart Contract & Programa autoejecutante almacenado en blockchain que ejecuta lógica de negocio cuando se cumplen condiciones. \\ \hline
Solidity & Lenguaje de programación orientado a objetos para escribir Smart Contracts en Ethereum. \\ \hline
Testnet & Red de prueba de blockchain que imita el funcionamiento de la red principal pero sin valor real. Ejemplo: Sepolia. \\ \hline
Transaction Hash & Identificador único de una transacción en blockchain, generado mediante hash criptográfico de su contenido. \\ \hline
TypeScript & Superset de JavaScript con tipado estático, usado para desarrollo backend del proyecto. \\ \hline
Wallet & Software que almacena claves privadas y permite firmar transacciones en blockchain. \\ \hline
\end{longtable}
